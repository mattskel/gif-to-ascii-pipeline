<!DOCTYPE html>
<html>
  <head>
    <title>Socket.IO chat</title>
    <style>
      body {
        font-family: "Courier New", Courier, monospace;
        white-space: pre-wrap;
        background: black;
        color: white;
        font-size: 0.5em;
      }
    </style>
  </head>
  <body>
    <div>
      <form id="myForm">
        <input type="text" name="searchTerm" autocomplete="off" /><button name="send">Send</button>
      </form>  
      <div id="whereTheTextGoes" style="font-size: 1.25em; line-height: 0.66em"></div>
      <img id="image" src="" alt="PNG Image">
    </div>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      var socket = io();
      var textArea = document.getElementById('whereTheTextGoes');
      var imgElement = document.getElementById('image');
      var myForm = document.getElementById('myForm');
      let timeoutId;
      let colorUrls = [];
      function loopAnimation(frames, delays) {
        var i = 0;
        var loop = function() {
          textArea.innerHTML = frames[i];
          const url = colorUrls[i];
          if (url) {
            imgElement.src = url;
          }
          timeoutId = setTimeout(loop, delays[i] * 10);
          i = (i + 1) % frames.length;
        }
        loop();
      }

      function stopAnimation(timeoutId, frames) {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        timeoutId = undefined;
        frames = [];
        // delays = [];
        // colorUrls = []; // You can't put this here. The color image comes back before the fetch returns
      }

      myForm.addEventListener('submit', function(event) {
        event.preventDefault();

        // disable the form so that it can't be changed while we're sending
        myForm.elements.searchTerm.disabled = true;
        myForm.elements.send.disabled = true;
        colorUrls = [];
        const formElement = event.target;
        const {value: searchTerm} = formElement.querySelector('input[name="searchTerm"]')

        let frames = [];
        let frameIndex = 0;
        let prevBuffer;;
        fetch(`/submit?searchTerm=${searchTerm}`, {
          method: 'GET',
        })
          .then((response) => response.body)
          .then((body) => {
            const reader = body.getReader();
            const decoder = new TextDecoder();

            let count = 0;
            stopAnimation(timeoutId, frames);

            // if (timeoutId) {
            //   clearTimeout(timeoutId);
            // }

            let previousTail = new Uint8Array([]);
            let incomingBufferSize = undefined;
            let previousBufferSize = undefined;
            function readStream() {
              return reader.read().then(({ done, value }) => {
                if (!done && !value) {
                  return readStream();
                }

                if (done) {
                  // enable the form again
                  myForm.elements.searchTerm.disabled = false;
                  myForm.elements.send.disabled = false;
                  loopAnimation(frames, [...prevBuffer.subarray(4)]);
                  return;
                }

                let buffer = new Uint8Array([...previousTail, ...value]);
                if (buffer.length < 4) {
                  previousTail = buffer;
                  return readStream();
                }

                const lengthArray = buffer.slice(0, 4);
                const incomingBufferSize = (lengthArray[3] << 24) | (lengthArray[2] << 16) | (lengthArray[1] << 8) | lengthArray[0];
                if (buffer.length < incomingBufferSize + 4) {
                  previousTail = buffer;
                  return readStream();
                }

                previousTail = new Uint8Array([]);
                if (prevBuffer) {
                  // if (timeoutId) {
                  //   clearTimeout(timeoutId);
                  // }

                  const subArray = prevBuffer.subarray(4)
                  const stringValue = decoder.decode(subArray).toString();
                  textArea.innerHTML = stringValue;
                  frames.push(stringValue);
                  const url = colorUrls[frames.length - 1];
                  if (url) {
                    imgElement.src = url;
                  }
                }

                prevBuffer = buffer;
                return readStream();
              });
            }

            // Start reading the streamed data
            return readStream();
          })

      })

      // socket.on('frame', (frame) => {
      //   textArea.innerHTML = frame;
      // });

      socket.on('colorFrame', (url) => {
        // console.log('colorFrame');
        // imgElement.src = url;
        colorUrls.push(url);
      });
    </script>
  </body>
</html>